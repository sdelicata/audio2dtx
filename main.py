import sys
import os
import logging
import argparse
from audio_to_chart import AudioToChart

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def is_interactive_environment():
    """Check if we're running in an interactive environment"""
    return sys.stdin.isatty() and sys.stdout.isatty()

def get_default_metadata(input_filename):
    """Get default metadata for batch mode"""
    return {
        'title': os.path.splitext(input_filename)[0],
        'artist': 'Unknown Artist',
        'author': 'Audio2DTX',
        'difficulty': 5,
        'use_original_bgm': True,
        'time_signature': '4/4',
        'genre': 'Rock',
        'comment': 'Auto-generated by Audio2DTX'
    }

def collect_metadata(input_filename, args=None):
    """Collect metadata from user input"""
    # Check if we're in an interactive environment
    if not is_interactive_environment():
        logger.warning("Non-interactive environment detected. Using default metadata.")
        return get_default_metadata(input_filename)
    
    print("\n=== Audio2DTX Metadata Collection ===")
    print("Please provide the following information for your DTX file:")
    print("(Press Enter for default values)")
    
    # Extract default title from filename
    default_title = os.path.splitext(input_filename)[0]
    
    # Collect metadata
    metadata = {}
    
    # Song title
    if args and args.title:
        metadata['title'] = args.title
    else:
        title = input(f"Song title [{default_title}]: ").strip()
        metadata['title'] = title if title else default_title
    
    # Artist name
    if args and args.artist:
        metadata['artist'] = args.artist
    else:
        artist = input("Artist name [Unknown Artist]: ").strip()
        metadata['artist'] = artist if artist else "Unknown Artist"
    
    # Author/Charter
    if args and args.author:
        metadata['author'] = args.author
    else:
        author = input("Author/Charter [Audio2DTX]: ").strip()
        metadata['author'] = author if author else "Audio2DTX"
    
    # Difficulty level
    while True:
        try:
            difficulty = input("Difficulty level (1-100) [5]: ").strip()
            if not difficulty:
                metadata['difficulty'] = 5
                break
            difficulty_val = int(difficulty)
            if 1 <= difficulty_val <= 100:
                metadata['difficulty'] = difficulty_val
                break
            else:
                print("Please enter a number between 1 and 100.")
        except ValueError:
            print("Please enter a valid number.")
    
    # Use original audio as BGM
    if args and args.use_original_bgm is not None:
        metadata['use_original_bgm'] = args.use_original_bgm
    elif args and args.no_original_bgm is not None:
        metadata['use_original_bgm'] = not args.no_original_bgm
    else:
        while True:
            use_original = input("Use original audio as BGM? (y/n) [y]: ").strip().lower()
            if not use_original or use_original in ['y', 'yes']:
                metadata['use_original_bgm'] = True
                break
            elif use_original in ['n', 'no']:
                metadata['use_original_bgm'] = False
                break
            else:
                print("Please enter 'y' for yes or 'n' for no.")
    
    # Time signature
    if args and args.time_signature:
        metadata['time_signature'] = args.time_signature
    else:
        print("\nAvailable time signatures:")
        print("1. 4/4 (default)")
        print("2. 3/4")
        print("3. 6/8")
        print("4. 2/4")
        print("5. 5/4")
        
        time_signatures = {
            '1': '4/4', '2': '3/4', '3': '6/8', '4': '2/4', '5': '5/4'
        }
        
        while True:
            time_sig_choice = input("Select time signature (1-5) [1]: ").strip()
            if not time_sig_choice:
                metadata['time_signature'] = '4/4'
                break
            elif time_sig_choice in time_signatures:
                metadata['time_signature'] = time_signatures[time_sig_choice]
                break
            else:
                print("Please enter a number between 1 and 5.")
    
    # Optional: Genre
    if args and args.genre:
        metadata['genre'] = args.genre
    else:
        genre = input("Genre [Rock]: ").strip()
        metadata['genre'] = genre if genre else "Rock"
    
    # Optional: Comment
    if args and args.comment:
        metadata['comment'] = args.comment
    else:
        comment = input("Comment [Auto-generated by Audio2DTX]: ").strip()
        metadata['comment'] = comment if comment else "Auto-generated by Audio2DTX"
    
    # Summary
    print("\n=== Metadata Summary ===")
    print(f"Title: {metadata['title']}")
    print(f"Artist: {metadata['artist']}")
    print(f"Author: {metadata['author']}")
    print(f"Difficulty: {metadata['difficulty']}")
    print(f"Use Original BGM: {'Yes' if metadata['use_original_bgm'] else 'No'}")
    print(f"Time Signature: {metadata['time_signature']}")
    print(f"Genre: {metadata['genre']}")
    print(f"Comment: {metadata['comment']}")
    
    # Confirmation
    while True:
        confirm = input("\nProceed with these settings? (y/n) [y]: ").strip().lower()
        if not confirm or confirm in ['y', 'yes']:
            break
        elif confirm in ['n', 'no']:
            print("Metadata collection cancelled.")
            sys.exit(0)
        else:
            print("Please enter 'y' for yes or 'n' for no.")
    
    return metadata

def main():
    """Main entry point for audio to DTX conversion"""
    parser = argparse.ArgumentParser(description='Convert audio files to DTXMania charts')
    parser.add_argument('input_file', help='Input audio file name')
    parser.add_argument('--batch', action='store_true', 
                       help='Run in batch mode (skip metadata prompts)')
    parser.add_argument('--interactive', action='store_true', default=True,
                       help='Run in interactive mode (prompt for metadata)')
    
    # Metadata arguments
    parser.add_argument('--title', help='Song title')
    parser.add_argument('--artist', help='Artist name')
    parser.add_argument('--author', help='Author/Charter name')
    parser.add_argument('--genre', help='Genre (default: Rock)')
    parser.add_argument('--comment', help='Comment')
    parser.add_argument('--use-original-bgm', action='store_true', default=None,
                       help='Use original audio as BGM')
    parser.add_argument('--no-original-bgm', action='store_true', default=None,
                       help='Do not use original audio as BGM')
    parser.add_argument('--time-signature', choices=['4/4', '3/4', '6/8', '2/4', '5/4'],
                       help='Time signature (default: 4/4)')
    
    # Track 3: Magenta-Only Classification
    parser.add_argument('--use-magenta-only', action='store_true',
                       help='Track 3: Use only Magenta service for drum classification (simplified approach)')
    
    # Track 4: Advanced Spectral Features + Context
    parser.add_argument('--use-advanced-features', action='store_true',
                       help='Track 4: Use advanced spectral features and enhanced context analysis')
    
    # Parse arguments, but handle backwards compatibility
    if len(sys.argv) < 2:
        print("Usage: python main.py <input_audio_file> [options]")
        print("Example: python main.py song.mp3")
        print("Example: python main.py song.mp3 --batch")
        print("Example: python main.py song.mp3 --title 'My Song' --artist 'My Band' --genre 'Metal'")
        print("Example: python main.py song.mp3 --use-original-bgm --time-signature 3/4")
        print("Example: python main.py song.mp3 --use-magenta-only --title 'MagentaOnly_Track3'")
        print("Example: python main.py song.mp3 --use-advanced-features --title 'AdvancedFeatures_Track4'")
        sys.exit(1)
    
    # Handle old-style command line (backwards compatibility)
    if len(sys.argv) == 2 and not sys.argv[1].startswith('--'):
        input_filename = sys.argv[1]
        batch_mode = False
        args = None
    else:
        args = parser.parse_args()
        input_filename = args.input_file
        batch_mode = args.batch
        
        # Handle BGM argument conflicts
        if args.use_original_bgm and args.no_original_bgm:
            logger.error("Cannot use both --use-original-bgm and --no-original-bgm")
            sys.exit(1)
    
    input_audio = f"/app/input/{input_filename}"
    output_dir = "/app/output"

    # Validate input file
    if not os.path.exists(input_audio):
        logger.error(f"File not found: {input_audio}")
        sys.exit(1)

    # Validate audio file format
    valid_formats = ['.mp3', '.wav', '.flac', '.ogg', '.m4a']
    file_ext = os.path.splitext(input_filename)[1].lower()
    if file_ext not in valid_formats:
        logger.error(f"Unsupported audio format: {file_ext}")
        logger.error(f"Supported formats: {', '.join(valid_formats)}")
        sys.exit(1)

    # Create output directory
    os.makedirs(output_dir, exist_ok=True)

    try:
        logger.info(f"Starting processing: {input_filename}")
        
        # Collect metadata from user or use defaults
        if batch_mode or not is_interactive_environment():
            metadata = get_default_metadata(input_filename)
            if batch_mode:
                logger.info("Running in batch mode - using default metadata")
            else:
                logger.info("Non-interactive environment detected - using default metadata")
        else:
            metadata = collect_metadata(input_filename, args)
        
        # Create chart converter instance with metadata
        use_magenta_only = args.use_magenta_only if args else False
        use_advanced_features = args.use_advanced_features if args else False
        chart = AudioToChart(input_audio, metadata, use_magenta_only=use_magenta_only, use_advanced_features=use_advanced_features)
        
        # Extract beats from audio
        logger.info("Extracting beats and creating chart...")
        chart.extract_beats()
        
        # Create DTX chart
        chart.create_chart()
        
        # Export complete simfile
        chart.export(output_dir)
        
        logger.info(f"‚úÖ Successfully converted {input_filename} to DTXMania simfile")
        logger.info(f"üìÅ Output saved to: {output_dir}")
        
    except Exception as e:
        logger.error(f"‚ùå Error processing audio file: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main()
