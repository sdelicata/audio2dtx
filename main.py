import sys
import os
import logging
import argparse

# Add src to Python path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from audio2dtx.config.settings import load_settings
from audio2dtx.core.audio_processor import AudioProcessor
from audio2dtx.utils.logging import setup_logging
from audio2dtx.utils.validators import validate_audio_file, validate_metadata
from audio2dtx.utils.exceptions import Audio2DTXError

# Setup logging
setup_logging(level="INFO")
logger = logging.getLogger('audio2dtx.main')

def is_interactive_environment():
    """Check if we're running in an interactive environment"""
    return sys.stdin.isatty() and sys.stdout.isatty()

def get_default_metadata(input_filename):
    """Get default metadata for batch mode"""
    return {
        'title': os.path.splitext(input_filename)[0],
        'artist': 'Unknown Artist',
        'author': 'Audio2DTX',
        'difficulty': 5,
        'use_original_bgm': True,
        'time_signature': '4/4',
        'genre': 'Rock',
        'comment': 'Auto-generated by Audio2DTX'
    }

def collect_metadata(input_filename, args=None):
    """Collect metadata from user input"""
    # Check if we're in an interactive environment
    if not is_interactive_environment():
        logger.warning("Non-interactive environment detected. Using default metadata.")
        return get_default_metadata(input_filename)
    
    print("\n=== Audio2DTX Metadata Collection ===")
    print("Please provide the following information for your DTX file:")
    print("(Press Enter for default values)")
    
    # Extract default title from filename
    default_title = os.path.splitext(input_filename)[0]
    
    # Collect metadata
    metadata = {}
    
    # Song title
    if args and args.title:
        metadata['title'] = args.title
    else:
        title = input(f"Song title [{default_title}]: ").strip()
        metadata['title'] = title if title else default_title
    
    # Artist name
    if args and args.artist:
        metadata['artist'] = args.artist
    else:
        artist = input("Artist name [Unknown Artist]: ").strip()
        metadata['artist'] = artist if artist else "Unknown Artist"
    
    # Author/Charter
    if args and args.author:
        metadata['author'] = args.author
    else:
        author = input("Author/Charter [Audio2DTX]: ").strip()
        metadata['author'] = author if author else "Audio2DTX"
    
    # Difficulty level
    while True:
        try:
            difficulty = input("Difficulty level (1-100) [5]: ").strip()
            if not difficulty:
                metadata['difficulty'] = 5
                break
            difficulty_val = int(difficulty)
            if 1 <= difficulty_val <= 100:
                metadata['difficulty'] = difficulty_val
                break
            else:
                print("Please enter a number between 1 and 100.")
        except ValueError:
            print("Please enter a valid number.")
    
    # Use original audio as BGM
    if args and args.use_original_bgm is not None:
        metadata['use_original_bgm'] = args.use_original_bgm
    elif args and args.no_original_bgm is not None:
        metadata['use_original_bgm'] = not args.no_original_bgm
    else:
        while True:
            use_original = input("Use original audio as BGM? (y/n) [y]: ").strip().lower()
            if not use_original or use_original in ['y', 'yes']:
                metadata['use_original_bgm'] = True
                break
            elif use_original in ['n', 'no']:
                metadata['use_original_bgm'] = False
                break
            else:
                print("Please enter 'y' for yes or 'n' for no.")
    
    # Time signature
    if args and args.time_signature:
        metadata['time_signature'] = args.time_signature
    else:
        print("\nAvailable time signatures:")
        print("1. 4/4 (default)")
        print("2. 3/4")
        print("3. 6/8")
        print("4. 2/4")
        print("5. 5/4")
        
        time_signatures = {
            '1': '4/4', '2': '3/4', '3': '6/8', '4': '2/4', '5': '5/4'
        }
        
        while True:
            time_sig_choice = input("Select time signature (1-5) [1]: ").strip()
            if not time_sig_choice:
                metadata['time_signature'] = '4/4'
                break
            elif time_sig_choice in time_signatures:
                metadata['time_signature'] = time_signatures[time_sig_choice]
                break
            else:
                print("Please enter a number between 1 and 5.")
    
    # Optional: Genre
    if args and args.genre:
        metadata['genre'] = args.genre
    else:
        genre = input("Genre [Rock]: ").strip()
        metadata['genre'] = genre if genre else "Rock"
    
    # Optional: Comment
    if args and args.comment:
        metadata['comment'] = args.comment
    else:
        comment = input("Comment [Auto-generated by Audio2DTX]: ").strip()
        metadata['comment'] = comment if comment else "Auto-generated by Audio2DTX"
    
    # Summary
    print("\n=== Metadata Summary ===")
    print(f"Title: {metadata['title']}")
    print(f"Artist: {metadata['artist']}")
    print(f"Author: {metadata['author']}")
    print(f"Difficulty: {metadata['difficulty']}")
    print(f"Use Original BGM: {'Yes' if metadata['use_original_bgm'] else 'No'}")
    print(f"Time Signature: {metadata['time_signature']}")
    print(f"Genre: {metadata['genre']}")
    print(f"Comment: {metadata['comment']}")
    
    # Confirmation
    while True:
        confirm = input("\nProceed with these settings? (y/n) [y]: ").strip().lower()
        if not confirm or confirm in ['y', 'yes']:
            break
        elif confirm in ['n', 'no']:
            print("Metadata collection cancelled.")
            sys.exit(0)
        else:
            print("Please enter 'y' for yes or 'n' for no.")
    
    return metadata

def determine_track_type(args):
    """Determine track type from command line arguments."""
    if args.use_magenta_only:
        return 'magenta_only'
    elif args.use_advanced_features:
        return 'advanced_features'
    elif args.use_multi_scale:
        return 'multi_scale'
    elif args.use_few_shot:
        return 'few_shot'
    elif args.use_ensemble:
        return 'ensemble'
    elif args.use_augmentation:
        return 'augmentation'
    elif args.use_rock_ultimate:
        return 'rock_ultimate'
    else:
        return 'default'

def main():
    """Main entry point for audio to DTX conversion"""
    parser = argparse.ArgumentParser(description='Convert audio files to DTXMania charts')
    parser.add_argument('input_file', help='Input audio file name')
    parser.add_argument('--batch', action='store_true', 
                       help='Run in batch mode (skip metadata prompts)')
    parser.add_argument('--interactive', action='store_true', default=True,
                       help='Run in interactive mode (prompt for metadata)')
    
    # Metadata arguments
    parser.add_argument('--title', help='Song title')
    parser.add_argument('--artist', help='Artist name')
    parser.add_argument('--author', help='Author/Charter name')
    parser.add_argument('--genre', help='Genre (default: Rock)')
    parser.add_argument('--comment', help='Comment')
    parser.add_argument('--use-original-bgm', action='store_true', default=None,
                       help='Use original audio as BGM')
    parser.add_argument('--no-original-bgm', action='store_true', default=None,
                       help='Do not use original audio as BGM')
    parser.add_argument('--time-signature', choices=['4/4', '3/4', '6/8', '2/4', '5/4'],
                       help='Time signature (default: 4/4)')
    
    # Track 3: Magenta-Only Classification
    parser.add_argument('--use-magenta-only', action='store_true',
                       help='Track 3: Use only Magenta service for drum classification (simplified approach)')
    
    # Track 4: Advanced Spectral Features + Context
    parser.add_argument('--use-advanced-features', action='store_true',
                       help='Track 4: Use advanced spectral features and enhanced context analysis')
    
    # Track 5: Multi-Scale Temporal Analysis
    parser.add_argument('--use-multi-scale', action='store_true',
                       help='Track 5: Use multi-scale temporal analysis for onset detection and classification')
    
    # Track 6: Real-Time Few-Shot Learning
    parser.add_argument('--use-few-shot', action='store_true',
                       help='Track 6: Use real-time few-shot learning for song-specific adaptation')
    
    # Track 7: Ensemble of Specialized Models
    parser.add_argument('--use-ensemble', action='store_true',
                       help='Track 7: Use ensemble of specialized models for hierarchical classification')
    
    # Track 8: Data Augmentation and Preprocessing
    parser.add_argument('--use-augmentation', action='store_true',
                       help='Track 8: Use advanced preprocessing and data augmentation for improved robustness')
    
    # Track 9: Ultimate Rock/Metal Hybrid
    parser.add_argument('--use-rock-ultimate', action='store_true',
                       help='Track 9: Ultimate rock/metal optimization combining all tracks for maximum accuracy')
    
    # Parse arguments, but handle backwards compatibility
    if len(sys.argv) < 2:
        print("Usage: python main.py <input_audio_file> [options]")
        print("Example: python main.py song.mp3")
        print("Example: python main.py song.mp3 --batch")
        print("Example: python main.py song.mp3 --title 'My Song' --artist 'My Band' --genre 'Metal'")
        print("Example: python main.py song.mp3 --use-original-bgm --time-signature 3/4")
        print("Example: python main.py song.mp3 --use-magenta-only --title 'MagentaOnly_Track3'")
        print("Example: python main.py song.mp3 --use-advanced-features --title 'AdvancedFeatures_Track4'")
        print("Example: python main.py song.mp3 --use-multi-scale --title 'MultiScale_Track5'")
        print("Example: python main.py song.mp3 --use-few-shot --title 'FewShot_Track6'")
        print("Example: python main.py song.mp3 --use-ensemble --title 'Ensemble_Track7'")
        print("Example: python main.py song.mp3 --use-augmentation --title 'Augmentation_Track8'")
        print("Example: python main.py song.mp3 --use-rock-ultimate --title 'RockUltimate_Track9'")
        sys.exit(1)
    
    # Handle old-style command line (backwards compatibility)
    if len(sys.argv) == 2 and not sys.argv[1].startswith('--'):
        input_filename = sys.argv[1]
        batch_mode = False
        args = None
    else:
        args = parser.parse_args()
        input_filename = args.input_file
        batch_mode = args.batch
        
        # Handle BGM argument conflicts
        if args.use_original_bgm and args.no_original_bgm:
            logger.error("Cannot use both --use-original-bgm and --no-original-bgm")
            sys.exit(1)
    
    input_audio = f"/app/input/{input_filename}"
    output_dir = "/app/output"

    # Validate input file
    if not os.path.exists(input_audio):
        logger.error(f"File not found: {input_audio}")
        sys.exit(1)

    # Validate audio file format
    valid_formats = ['.mp3', '.wav', '.flac', '.ogg', '.m4a']
    file_ext = os.path.splitext(input_filename)[1].lower()
    if file_ext not in valid_formats:
        logger.error(f"Unsupported audio format: {file_ext}")
        logger.error(f"Supported formats: {', '.join(valid_formats)}")
        sys.exit(1)

    # Create output directory
    os.makedirs(output_dir, exist_ok=True)

    try:
        logger.info(f"Starting processing: {input_filename}")
        
        # Collect metadata from user or use defaults
        if batch_mode or not is_interactive_environment():
            metadata = get_default_metadata(input_filename)
            if batch_mode:
                logger.info("Running in batch mode - using default metadata")
            else:
                logger.info("Non-interactive environment detected - using default metadata")
        else:
            metadata = collect_metadata(input_filename, args)
        
        # Override with command line arguments if provided
        if args:
            if args.title:
                metadata['title'] = args.title
            if args.artist:
                metadata['artist'] = args.artist
            if args.author:
                metadata['author'] = args.author
            if args.genre:
                metadata['genre'] = args.genre
            if args.comment:
                metadata['comment'] = args.comment
            if args.use_original_bgm is not None:
                metadata['use_original_bgm'] = args.use_original_bgm
            if args.no_original_bgm is not None:
                metadata['use_original_bgm'] = not args.no_original_bgm
            if args.time_signature:
                metadata['time_signature'] = args.time_signature
        
        # Validate inputs
        input_audio = validate_audio_file(input_audio)
        metadata = validate_metadata(metadata)
        
        # Load settings and initialize processor
        settings = load_settings()
        processor = AudioProcessor(settings)
        
        # Determine track type
        track_type = determine_track_type(args) if args else 'default'
        
        logger.info(f"🎯 Using track type: {track_type}")
        
        # Process audio file
        dtx_path = processor.process_audio_file(
            input_file=input_audio,
            output_dir=output_dir,
            metadata=metadata,
            track_type=track_type
        )
        
        # Get processing results
        results = processor.get_processing_results()
        
        logger.info(f"✅ Successfully converted {input_filename} to DTXMania simfile")
        logger.info(f"📁 Output saved to: {dtx_path}")
        
        # Safely access beat_result attributes
        beat_result = results.get('beat_result')
        if beat_result and hasattr(beat_result, 'tempo_bpm'):
            logger.info(f"🎵 Tempo: {beat_result.tempo_bpm} BPM")
        else:
            logger.info(f"🎵 Tempo: Unknown BPM")
            
        logger.info(f"🥁 Onsets detected: {results.get('onset_count', 0)}")
        logger.info(f"🎶 Notes generated: {results.get('classified_count', 0)}")
        
    except Audio2DTXError as e:
        logger.error(f"❌ Audio2DTX Error: {str(e)}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"❌ Error processing audio file: {str(e)}")
        sys.exit(1)
    finally:
        # Clean up if processor exists
        if 'processor' in locals():
            processor.cleanup()

if __name__ == "__main__":
    main()
