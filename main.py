import sys
import os
import logging
import argparse
import time

# Add src to Python path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from audio2dtx.config.settings import load_settings
from audio2dtx.core.audio_processor import AudioProcessor
from audio2dtx.utils.logging import setup_logging
from audio2dtx.utils.validators import validate_audio_file, validate_metadata
from audio2dtx.utils.exceptions import Audio2DTXError

# Setup logging
setup_logging(level="INFO")
logger = logging.getLogger('audio2dtx.main')

def is_interactive_environment():
    """Check if we're running in an interactive environment"""
    return sys.stdin.isatty() and sys.stdout.isatty()

def get_default_metadata(input_filename):
    """Get default metadata for batch mode"""
    return {
        'title': os.path.splitext(input_filename)[0],
        'artist': 'Unknown Artist',
        'author': 'Audio2DTX',
        'difficulty': 5,
        'use_original_bgm': True,
        'time_signature': '4/4',
        'genre': 'Rock',
        'comment': 'Auto-generated by Audio2DTX'
    }

def collect_metadata(input_filename, args=None):
    """Collect metadata from user input"""
    # Check if we're in an interactive environment
    if not is_interactive_environment():
        logger.warning("Non-interactive environment detected. Using default metadata.")
        return get_default_metadata(input_filename)
    
    print("\n=== Audio2DTX Metadata Collection ===")
    print("Please provide the following information for your DTX file:")
    print("(Press Enter for default values)")
    
    # Extract default title from filename
    default_title = os.path.splitext(input_filename)[0]
    
    # Collect metadata
    metadata = {}
    
    # Song title
    if args and args.title:
        metadata['title'] = args.title
    else:
        title = input(f"Song title [{default_title}]: ").strip()
        metadata['title'] = title if title else default_title
    
    # Artist name
    if args and args.artist:
        metadata['artist'] = args.artist
    else:
        artist = input("Artist name [Unknown Artist]: ").strip()
        metadata['artist'] = artist if artist else "Unknown Artist"
    
    # Author/Charter
    if args and args.author:
        metadata['author'] = args.author
    else:
        author = input("Author/Charter [Audio2DTX]: ").strip()
        metadata['author'] = author if author else "Audio2DTX"
    
    # Difficulty level
    while True:
        try:
            difficulty = input("Difficulty level (1-100) [5]: ").strip()
            if not difficulty:
                metadata['difficulty'] = 5
                break
            difficulty_val = int(difficulty)
            if 1 <= difficulty_val <= 100:
                metadata['difficulty'] = difficulty_val
                break
            else:
                print("Please enter a number between 1 and 100.")
        except ValueError:
            print("Please enter a valid number.")
    
    # Use original audio as BGM
    if args and args.use_original_bgm is not None:
        metadata['use_original_bgm'] = args.use_original_bgm
    elif args and args.no_original_bgm is not None:
        metadata['use_original_bgm'] = not args.no_original_bgm
    else:
        while True:
            use_original = input("Use original audio as BGM? (y/n) [y]: ").strip().lower()
            if not use_original or use_original in ['y', 'yes']:
                metadata['use_original_bgm'] = True
                break
            elif use_original in ['n', 'no']:
                metadata['use_original_bgm'] = False
                break
            else:
                print("Please enter 'y' for yes or 'n' for no.")
    
    # Time signature
    if args and args.time_signature:
        metadata['time_signature'] = args.time_signature
    else:
        print("\nAvailable time signatures:")
        print("1. 4/4 (default)")
        print("2. 3/4")
        print("3. 6/8")
        print("4. 2/4")
        print("5. 5/4")
        
        time_signatures = {
            '1': '4/4', '2': '3/4', '3': '6/8', '4': '2/4', '5': '5/4'
        }
        
        while True:
            time_sig_choice = input("Select time signature (1-5) [1]: ").strip()
            if not time_sig_choice:
                metadata['time_signature'] = '4/4'
                break
            elif time_sig_choice in time_signatures:
                metadata['time_signature'] = time_signatures[time_sig_choice]
                break
            else:
                print("Please enter a number between 1 and 5.")
    
    # Optional: Genre
    if args and args.genre:
        metadata['genre'] = args.genre
    else:
        genre = input("Genre [Rock]: ").strip()
        metadata['genre'] = genre if genre else "Rock"
    
    # Optional: Comment
    if args and args.comment:
        metadata['comment'] = args.comment
    else:
        comment = input("Comment [Auto-generated by Audio2DTX]: ").strip()
        metadata['comment'] = comment if comment else "Auto-generated by Audio2DTX"
    
    # Summary
    print("\n=== Metadata Summary ===")
    print(f"Title: {metadata['title']}")
    print(f"Artist: {metadata['artist']}")
    print(f"Author: {metadata['author']}")
    print(f"Difficulty: {metadata['difficulty']}")
    print(f"Use Original BGM: {'Yes' if metadata['use_original_bgm'] else 'No'}")
    print(f"Time Signature: {metadata['time_signature']}")
    print(f"Genre: {metadata['genre']}")
    print(f"Comment: {metadata['comment']}")
    
    # Confirmation
    while True:
        confirm = input("\nProceed with these settings? (y/n) [y]: ").strip().lower()
        if not confirm or confirm in ['y', 'yes']:
            break
        elif confirm in ['n', 'no']:
            print("Metadata collection cancelled.")
            sys.exit(0)
        else:
            print("Please enter 'y' for yes or 'n' for no.")
    
    return metadata

def determine_track_type(args):
    """Determine track type from command line arguments."""
    if args.use_magenta_only:
        return 'magenta_only'
    elif args.use_advanced_features:
        return 'advanced_features'
    elif args.use_multi_scale:
        return 'multi_scale'
    elif args.use_few_shot:
        return 'few_shot'
    elif args.use_ensemble:
        return 'ensemble'
    elif args.use_augmentation:
        return 'augmentation'
    elif args.use_rock_ultimate:
        return 'rock_ultimate'
    else:
        return 'default'

def get_all_track_types():
    """Get all available track types for comparison."""
    return [
        ('default', 'Default Hybrid'),
        ('magenta_only', 'Track 3: Magenta-Only'),
        ('advanced_features', 'Track 4: Advanced Features'),
        ('multi_scale', 'Track 5: Multi-Scale'),
        ('few_shot', 'Track 6: Few-Shot Learning'),
        ('ensemble', 'Track 7: Ensemble'),
        ('augmentation', 'Track 8: Augmentation'),
        ('rock_ultimate', 'Track 9: Rock Ultimate')
    ]

def process_all_tracks(input_audio, base_output_dir, metadata, input_filename):
    """Process audio file with all available tracks for comparison."""
    
    # Get all track types
    all_tracks = get_all_track_types()
    
    # Results storage
    comparison_results = []
    
    logger.info(f"🔄 Starting comparison processing with {len(all_tracks)} tracks")
    logger.info(f"📁 Results will be saved in separate folders under: {base_output_dir}")
    
    # Process each track
    for track_type, track_name in all_tracks:
        logger.info(f"🎯 Processing {track_name} ({track_type})")
        
        # Create track-specific output directory
        track_output_dir = os.path.join(base_output_dir, f"track_{track_type}")
        os.makedirs(track_output_dir, exist_ok=True)
        
        # Record start time
        start_time = time.time()
        
        try:
            # Load settings and initialize processor
            settings = load_settings()
            processor = AudioProcessor(settings)
            
            # Process audio file with specific track
            dtx_path = processor.process_audio_file(
                input_file=input_audio,
                output_dir=track_output_dir,
                metadata=metadata,
                track_type=track_type
            )
            
            # Get processing results
            results = processor.get_processing_results()
            processing_time = time.time() - start_time
            
            # Store results
            comparison_results.append({
                'track_type': track_type,
                'track_name': track_name,
                'processing_time': processing_time,
                'onset_count': results.get('onset_count', 0),
                'classified_count': results.get('classified_count', 0),
                'output_path': dtx_path,
                'success': True,
                'error': None
            })
            
            logger.info(f"✅ {track_name} completed in {processing_time:.1f}s")
            
            # Clean up processor
            processor.cleanup()
            
        except Exception as e:
            processing_time = time.time() - start_time
            logger.error(f"❌ {track_name} failed: {str(e)}")
            
            comparison_results.append({
                'track_type': track_type,
                'track_name': track_name,
                'processing_time': processing_time,
                'onset_count': 0,
                'classified_count': 0,
                'output_path': None,
                'success': False,
                'error': str(e)
            })
    
    # Generate comparison report
    generate_comparison_report(comparison_results, base_output_dir, input_filename)
    
    return comparison_results

def generate_comparison_report(results, output_dir, input_filename):
    """Generate a comparison report of all track results."""
    report_path = os.path.join(output_dir, "comparison_report.txt")
    
    with open(report_path, 'w') as f:
        f.write("=== AUDIO2DTX TRACK COMPARISON REPORT ===\n\n")
        f.write(f"Input file: {input_filename}\n")
        f.write(f"Total tracks tested: {len(results)}\n")
        f.write(f"Successful conversions: {sum(1 for r in results if r['success'])}\n")
        f.write(f"Failed conversions: {sum(1 for r in results if not r['success'])}\n\n")
        
        # Summary table
        f.write("SUMMARY TABLE:\n")
        f.write("=" * 80 + "\n")
        f.write(f"{'Track Name':<25} {'Status':<10} {'Time(s)':<10} {'Onsets':<10} {'Notes':<10}\n")
        f.write("-" * 80 + "\n")
        
        for result in results:
            status = "SUCCESS" if result['success'] else "FAILED"
            f.write(f"{result['track_name']:<25} {status:<10} {result['processing_time']:<10.1f} "
                   f"{result['onset_count']:<10} {result['classified_count']:<10}\n")
        
        f.write("\nDETAILED RESULTS:\n")
        f.write("=" * 80 + "\n")
        
        for result in results:
            f.write(f"\n{result['track_name']} ({result['track_type']}):\n")
            f.write(f"  Status: {'SUCCESS' if result['success'] else 'FAILED'}\n")
            f.write(f"  Processing Time: {result['processing_time']:.1f} seconds\n")
            f.write(f"  Onsets Detected: {result['onset_count']}\n")
            f.write(f"  Notes Generated: {result['classified_count']}\n")
            f.write(f"  Output: {result['output_path'] if result['success'] else 'N/A'}\n")
            if result['error']:
                f.write(f"  Error: {result['error']}\n")
        
        # Recommendations
        f.write("\nRECOMMENDATIONS:\n")
        f.write("=" * 80 + "\n")
        
        successful_results = [r for r in results if r['success']]
        if successful_results:
            # Find fastest track
            fastest = min(successful_results, key=lambda r: r['processing_time'])
            f.write(f"Fastest processing: {fastest['track_name']} ({fastest['processing_time']:.1f}s)\n")
            
            # Find track with most onsets
            most_onsets = max(successful_results, key=lambda r: r['onset_count'])
            f.write(f"Most onsets detected: {most_onsets['track_name']} ({most_onsets['onset_count']} onsets)\n")
            
            # Find track with most classified notes
            most_notes = max(successful_results, key=lambda r: r['classified_count'])
            f.write(f"Most notes generated: {most_notes['track_name']} ({most_notes['classified_count']} notes)\n")
        
        f.write(f"\nReport generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
    
    logger.info(f"📊 Comparison report saved to: {report_path}")
    return report_path

def main():
    """Main entry point for audio to DTX conversion"""
    parser = argparse.ArgumentParser(description='Convert audio files to DTXMania charts')
    parser.add_argument('input_file', help='Input audio file name')
    parser.add_argument('--batch', action='store_true', 
                       help='Run in batch mode (skip metadata prompts)')
    parser.add_argument('--interactive', action='store_true', default=True,
                       help='Run in interactive mode (prompt for metadata)')
    
    # Metadata arguments
    parser.add_argument('--title', help='Song title')
    parser.add_argument('--artist', help='Artist name')
    parser.add_argument('--author', help='Author/Charter name')
    parser.add_argument('--genre', help='Genre (default: Rock)')
    parser.add_argument('--comment', help='Comment')
    parser.add_argument('--use-original-bgm', action='store_true', default=None,
                       help='Use original audio as BGM')
    parser.add_argument('--no-original-bgm', action='store_true', default=None,
                       help='Do not use original audio as BGM')
    parser.add_argument('--time-signature', choices=['4/4', '3/4', '6/8', '2/4', '5/4'],
                       help='Time signature (default: 4/4)')
    
    # Track 3: Magenta-Only Classification
    parser.add_argument('--use-magenta-only', action='store_true',
                       help='Track 3: Use only Magenta service for drum classification (simplified approach)')
    
    # Track 4: Advanced Spectral Features + Context
    parser.add_argument('--use-advanced-features', action='store_true',
                       help='Track 4: Use advanced spectral features and enhanced context analysis')
    
    # Track 5: Multi-Scale Temporal Analysis
    parser.add_argument('--use-multi-scale', action='store_true',
                       help='Track 5: Use multi-scale temporal analysis for onset detection and classification')
    
    # Track 6: Real-Time Few-Shot Learning
    parser.add_argument('--use-few-shot', action='store_true',
                       help='Track 6: Use real-time few-shot learning for song-specific adaptation')
    
    # Track 7: Ensemble of Specialized Models
    parser.add_argument('--use-ensemble', action='store_true',
                       help='Track 7: Use ensemble of specialized models for hierarchical classification')
    
    # Track 8: Data Augmentation and Preprocessing
    parser.add_argument('--use-augmentation', action='store_true',
                       help='Track 8: Use advanced preprocessing and data augmentation for improved robustness')
    
    # Track 9: Ultimate Rock/Metal Hybrid
    parser.add_argument('--use-rock-ultimate', action='store_true',
                       help='Track 9: Ultimate rock/metal optimization combining all tracks for maximum accuracy')
    
    # Compare all tracks option
    parser.add_argument('--compare-all-tracks', action='store_true',
                       help='Generate conversions using all available tracks for comparison (creates separate output folders)')
    
    # Parse arguments, but handle backwards compatibility
    if len(sys.argv) < 2:
        print("Usage: python main.py <input_audio_file> [options]")
        print("Example: python main.py song.mp3")
        print("Example: python main.py song.mp3 --batch")
        print("Example: python main.py song.mp3 --title 'My Song' --artist 'My Band' --genre 'Metal'")
        print("Example: python main.py song.mp3 --use-original-bgm --time-signature 3/4")
        print("Example: python main.py song.mp3 --use-magenta-only --title 'MagentaOnly_Track3'")
        print("Example: python main.py song.mp3 --use-advanced-features --title 'AdvancedFeatures_Track4'")
        print("Example: python main.py song.mp3 --use-multi-scale --title 'MultiScale_Track5'")
        print("Example: python main.py song.mp3 --use-few-shot --title 'FewShot_Track6'")
        print("Example: python main.py song.mp3 --use-ensemble --title 'Ensemble_Track7'")
        print("Example: python main.py song.mp3 --use-augmentation --title 'Augmentation_Track8'")
        print("Example: python main.py song.mp3 --use-rock-ultimate --title 'RockUltimate_Track9'")
        print("Example: python main.py song.mp3 --compare-all-tracks --batch")
        sys.exit(1)
    
    # Handle old-style command line (backwards compatibility)
    if len(sys.argv) == 2 and not sys.argv[1].startswith('--'):
        input_filename = sys.argv[1]
        batch_mode = False
        args = None
    else:
        args = parser.parse_args()
        input_filename = args.input_file
        batch_mode = args.batch
        
        # Handle BGM argument conflicts
        if args.use_original_bgm and args.no_original_bgm:
            logger.error("Cannot use both --use-original-bgm and --no-original-bgm")
            sys.exit(1)
    
    input_audio = f"/app/input/{input_filename}"
    output_dir = "/app/output"

    # Validate input file
    if not os.path.exists(input_audio):
        logger.error(f"File not found: {input_audio}")
        sys.exit(1)

    # Validate audio file format
    valid_formats = ['.mp3', '.wav', '.flac', '.ogg', '.m4a']
    file_ext = os.path.splitext(input_filename)[1].lower()
    if file_ext not in valid_formats:
        logger.error(f"Unsupported audio format: {file_ext}")
        logger.error(f"Supported formats: {', '.join(valid_formats)}")
        sys.exit(1)

    # Create output directory
    os.makedirs(output_dir, exist_ok=True)

    try:
        logger.info(f"Starting processing: {input_filename}")
        
        # Collect metadata from user or use defaults
        if batch_mode or not is_interactive_environment():
            metadata = get_default_metadata(input_filename)
            if batch_mode:
                logger.info("Running in batch mode - using default metadata")
            else:
                logger.info("Non-interactive environment detected - using default metadata")
        else:
            metadata = collect_metadata(input_filename, args)
        
        # Override with command line arguments if provided
        if args:
            if args.title:
                metadata['title'] = args.title
            if args.artist:
                metadata['artist'] = args.artist
            if args.author:
                metadata['author'] = args.author
            if args.genre:
                metadata['genre'] = args.genre
            if args.comment:
                metadata['comment'] = args.comment
            if args.use_original_bgm is not None:
                metadata['use_original_bgm'] = args.use_original_bgm
            if args.no_original_bgm is not None:
                metadata['use_original_bgm'] = not args.no_original_bgm
            if args.time_signature:
                metadata['time_signature'] = args.time_signature
        
        # Validate inputs
        input_audio = validate_audio_file(input_audio)
        metadata = validate_metadata(metadata)
        
        # Check if we should compare all tracks
        if args and args.compare_all_tracks:
            logger.info("🔄 Starting comparison mode - processing all tracks")
            
            # Process all tracks
            comparison_results = process_all_tracks(input_audio, output_dir, metadata, input_filename)
            
            # Summary
            successful_tracks = [r for r in comparison_results if r['success']]
            failed_tracks = [r for r in comparison_results if not r['success']]
            
            logger.info(f"✅ Comparison completed: {len(successful_tracks)} successful, {len(failed_tracks)} failed")
            logger.info(f"📊 Results saved in {len(successful_tracks)} separate folders")
            logger.info(f"📋 See comparison_report.txt for detailed analysis")
            
            # Return early for comparison mode
            return
        
        # Single track processing (default behavior)
        # Load settings and initialize processor
        settings = load_settings()
        processor = AudioProcessor(settings)
        
        # Determine track type
        track_type = determine_track_type(args) if args else 'default'
        
        logger.info(f"🎯 Using track type: {track_type}")
        
        # Process audio file
        dtx_path = processor.process_audio_file(
            input_file=input_audio,
            output_dir=output_dir,
            metadata=metadata,
            track_type=track_type
        )
        
        # Get processing results
        results = processor.get_processing_results()
        
        logger.info(f"✅ Successfully converted {input_filename} to DTXMania simfile")
        logger.info(f"📁 Output saved to: {dtx_path}")
        
        # Safely access beat_result attributes
        beat_result = results.get('beat_result')
        if beat_result and hasattr(beat_result, 'tempo_bpm'):
            logger.info(f"🎵 Tempo: {beat_result.tempo_bpm} BPM")
        else:
            logger.info(f"🎵 Tempo: Unknown BPM")
            
        logger.info(f"🥁 Onsets detected: {results.get('onset_count', 0)}")
        logger.info(f"🎶 Notes generated: {results.get('classified_count', 0)}")
        
    except Audio2DTXError as e:
        logger.error(f"❌ Audio2DTX Error: {str(e)}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"❌ Error processing audio file: {str(e)}")
        sys.exit(1)
    finally:
        # Clean up if processor exists
        if 'processor' in locals():
            processor.cleanup()

if __name__ == "__main__":
    main()
