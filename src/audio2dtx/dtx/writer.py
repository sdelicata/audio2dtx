"""
DTX file writing and generation.
"""

import os
import zipfile
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

from ..config.settings import Settings
from ..config.constants import DTX_CHANNELS, DTX_RESOLUTION, INT_TO_CHANNEL
from ..utils.exceptions import DTXGenerationError
from ..utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class DTXNote:
    """Represents a single DTX note."""
    bar: int
    position: int
    channel: str
    velocity: int = 127
    
    def to_dtx_format(self) -> str:
        """Convert note to DTX format string."""
        velocity_hex = format(self.velocity, '02X')
        return velocity_hex


@dataclass
class DTXChart:
    """Represents a complete DTX chart."""
    metadata: Dict[str, Any]
    notes: List[DTXNote]
    bar_count: int = 0
    
    def add_note(self, bar: int, position: int, instrument: str, velocity: int = 127):
        """Add a note to the chart."""
        if instrument in DTX_CHANNELS:
            channel = DTX_CHANNELS[instrument]
            note = DTXNote(bar, position, channel, velocity)
            self.notes.append(note)
        else:
            logger.warning(f"Unknown instrument: {instrument}")


class DTXWriter:
    """
    DTX file writer for generating DTXMania chart files.
    """
    
    def __init__(self, settings: Settings):
        """
        Initialize DTX writer.
        
        Args:
            settings: Application settings
        """
        self.settings = settings
        self.resolution = settings.dtx.resolution
        self.bars_before_song = settings.dtx.bars_before_song
        
    def create_dtx_header(self, metadata: Dict[str, Any], bgm_format: str = "wav") -> str:
        """
        Create DTX file header with metadata.
        
        Args:
            metadata: Song metadata
            bgm_format: Format of BGM file (mp3 or wav)
            
        Returns:
            DTX header string
        """
        title = metadata.get('title', 'Unknown Title')
        artist = metadata.get('artist', 'Unknown Artist') 
        author = metadata.get('author', 'Audio2DTX')
        genre = metadata.get('genre', 'Rock')
        comment = metadata.get('comment', 'Auto-generated by Audio2DTX')
        difficulty = metadata.get('difficulty', 5)
        use_original_bgm = metadata.get('use_original_bgm', True)
        bpm = metadata.get('bpm', 120)  # Use detected BPM or default to 120
        
        # DTX header format
        header = f"""#TITLE: {title}
#ARTIST: {artist}
#COMMENT: {comment}
#DLEVEL: {difficulty}
#GENRE: {genre}
#MAKER: {author}
#BPM: {bpm:.1f}

"""
        
        # Add WAV definitions for drum sounds
        wav_definitions = self._create_wav_definitions(use_original_bgm, bgm_format)
        header += wav_definitions + "\n"
        
        return header
    
    def _create_wav_definitions(self, use_original_bgm: bool = True, bgm_format: str = "wav") -> str:
        """Create WAV file definitions for DTX."""
        definitions = []
        
        # BGM definition - DTXMania works best with WAV format
        if use_original_bgm:
            definitions.append(f"#WAV01: bgm.{bgm_format}")
        else:
            definitions.append(f"#WAV01: bgm_separated.{bgm_format}")
        
        # Drum sound definitions
        drum_wavs = {
            '11': 'hihat_close.ogg',    # Hi-hat close
            '12': 'snare.ogg',          # Snare
            '13': 'kick.ogg',           # Kick
            '14': 'tom_high.ogg',       # Tom high
            '15': 'tom_low.ogg',        # Tom low  
            '16': 'ride.ogg',           # Ride
            '17': 'tom_floor.ogg',      # Tom floor
            '18': 'hihat_open.ogg',     # Hi-hat open
            '19': 'ride_bell.ogg',      # Ride bell
            '1A': 'crash.ogg'           # Crash
        }
        
        for wav_id, filename in drum_wavs.items():
            definitions.append(f"#WAV{wav_id}: {filename}")
        
        return "\n".join(definitions)
    
    def generate_notes_from_onsets(self, 
                                  onset_data: Dict[int, List[float]],
                                  beat_times: List[float],
                                  tempo_bpm: float) -> List[DTXNote]:
        """
        Generate DTX notes from onset data.
        
        Args:
            onset_data: Dictionary mapping instruments to onset times
            beat_times: List of beat times in seconds
            tempo_bpm: Song tempo in BPM
            
        Returns:
            List of DTX notes
        """
        notes = []
        
        if not beat_times:
            logger.warning("No beat times available for note generation")
            return notes
        
        # Debug: log input data
        total_input_onsets = sum(len(times) for times in onset_data.values())
        logger.info(f"Processing {total_input_onsets} input onsets from {len(onset_data)} instruments")
        
        # Calculate bar duration (4 beats per bar)
        bar_duration = 240.0 / tempo_bpm  # 4 beats in seconds
        
        for instrument_id, onset_times in onset_data.items():
            if instrument_id not in INT_TO_CHANNEL:
                logger.warning(f"Unknown instrument ID: {instrument_id}, skipping")
                continue
                
            channel = INT_TO_CHANNEL[instrument_id]
            logger.debug(f"Processing {len(onset_times)} onsets for instrument {instrument_id} (channel {channel})")
            
            for onset_time in onset_times:
                # Convert onset time to bar and position
                bar_num = int(onset_time / bar_duration) + self.bars_before_song
                bar_time = onset_time - ((bar_num - self.bars_before_song) * bar_duration)
                
                # Calculate position within bar (0 to resolution-1)
                position = int((bar_time / bar_duration) * self.resolution)
                position = max(0, min(position, self.resolution - 1))
                
                # Create note
                note = DTXNote(
                    bar=bar_num,
                    position=position,
                    channel=channel,
                    velocity=127  # Default velocity
                )
                
                notes.append(note)
        
        # Sort notes by bar and position
        notes.sort(key=lambda n: (n.bar, n.position))
        
        logger.info(f"Generated {len(notes)} DTX notes")
        return notes
    
    def write_dtx_content(self, 
                         chart: DTXChart,
                         output_path: str,
                         bgm_format: str = "mp3") -> None:
        """
        Write DTX chart to file.
        
        Args:
            chart: DTX chart data
            output_path: Output file path
            bgm_format: Format of BGM file (mp3 or wav)
            
        Raises:
            DTXGenerationError: If writing fails
        """
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                # Write header
                header = self.create_dtx_header(chart.metadata, bgm_format)
                f.write(header)
                
                # Organize notes by bar and channel
                bar_data = {}
                max_bar = 0
                
                for note in chart.notes:
                    if note.bar not in bar_data:
                        bar_data[note.bar] = {}
                    if note.channel not in bar_data[note.bar]:
                        bar_data[note.bar][note.channel] = ['00'] * self.resolution
                    
                    # Place note
                    bar_data[note.bar][note.channel][note.position] = note.to_dtx_format()
                    max_bar = max(max_bar, note.bar)
                
                # Write BGM start line (reference to WAV01)
                f.write(f'#{self.bars_before_song:03}01: 01\n')
                
                # Write note data
                for bar_num in range(max_bar + 1):
                    if bar_num in bar_data:
                        for channel, note_data in bar_data[bar_num].items():
                            # Convert note data to string
                            note_string = ''.join(note_data)
                            # Only write if there are notes (not all zeros)
                            if any(note != '00' for note in note_data):
                                f.write(f'#{bar_num:03}{channel}: {note_string}\n')
                
            logger.info(f"DTX file written to {output_path}")
            
        except Exception as e:
            raise DTXGenerationError(f"Failed to write DTX file: {e}")
    
    def create_complete_dtx_package(self, 
                                   chart: DTXChart,
                                   bgm_audio_path: Optional[str],
                                   drum_sounds_dir: Optional[str],
                                   output_dir: str,
                                   song_name: str) -> str:
        """
        Create complete DTX package with all required files in directory structure.
        
        Args:
            chart: DTX chart data
            bgm_audio_path: Path to BGM audio file
            drum_sounds_dir: Directory containing drum sound files
            output_dir: Output directory
            song_name: Base name for the song
            
        Returns:
            Path to created directory
            
        Raises:
            DTXGenerationError: If package creation fails
        """
        try:
            # Create song directory
            song_dir = os.path.join(output_dir, song_name)
            os.makedirs(song_dir, exist_ok=True)
            
            # Determine BGM format first - prefer WAV for DTXMania compatibility
            bgm_format = "wav"  # Default to WAV for better DTXMania compatibility
            if bgm_audio_path and os.path.exists(bgm_audio_path):
                if bgm_audio_path.endswith('.mp3'):
                    bgm_format = "mp3"
            
            # Create DTX file in the song directory
            dtx_path = os.path.join(song_dir, f"{song_name}.dtx")
            self.write_dtx_content(chart, dtx_path, bgm_format)
            
            # Copy BGM file
            if bgm_audio_path and os.path.exists(bgm_audio_path):
                # Determine BGM filename based on detected format
                if bgm_format == "wav":
                    bgm_name = "bgm.wav" if chart.metadata.get('use_original_bgm', True) else "bgm_separated.wav"
                else:
                    bgm_name = "bgm.mp3" if chart.metadata.get('use_original_bgm', True) else "bgm_separated.mp3"
                
                bgm_dest_path = os.path.join(song_dir, bgm_name)
                
                import shutil
                shutil.copy2(bgm_audio_path, bgm_dest_path)
                logger.info(f"Added BGM file: {bgm_name}")
            
            # Copy drum sounds
            if drum_sounds_dir and os.path.exists(drum_sounds_dir):
                drum_files = [
                    'hihat_close.ogg', 'snare.ogg', 'kick.ogg',
                    'tom_high.ogg', 'tom_low.ogg', 'ride.ogg',
                    'tom_floor.ogg', 'hihat_open.ogg', 'ride_bell.ogg', 'crash.ogg'
                ]
                
                for drum_file in drum_files:
                    drum_path = os.path.join(drum_sounds_dir, drum_file)
                    if os.path.exists(drum_path):
                        dest_path = os.path.join(song_dir, drum_file)
                        shutil.copy2(drum_path, dest_path)
                    else:
                        logger.warning(f"Drum sound file not found: {drum_path}")
            
            # Extract template files directly to directory
            self._extract_template_files(song_dir)
            
            # Validate DTX package
            validation_issues = self._validate_dtx_package(song_dir, bgm_format)
            if validation_issues:
                logger.warning(f"DTX package validation issues: {validation_issues}")
            
            logger.info(f"Created DTX package directory: {song_dir}")
            return song_dir
            
        except Exception as e:
            raise DTXGenerationError(f"Failed to create DTX package: {e}")
    
    def _extract_template_files(self, song_dir: str):
        """Extract template files directly to song directory."""
        try:
            # Check for template file
            template_path = "SimfilesTemplate.zip"
            
            if os.path.exists(template_path):
                with zipfile.ZipFile(template_path, 'r') as template_zip:
                    # Extract drum sound files from template
                    for file_info in template_zip.filelist:
                        if file_info.filename.endswith('.ogg'):
                            # Extract file
                            data = template_zip.read(file_info.filename)
                            
                            # Get just the filename without the directory structure
                            filename = os.path.basename(file_info.filename)
                            
                            # Map template filenames to expected DTX filenames
                            filename_mapping = {
                                'low_tom.ogg': 'tom_low.ogg',
                                'high_tom.ogg': 'tom_high.ogg',
                                'floor_tom.ogg': 'tom_floor.ogg',
                                # Other files keep their original names
                            }
                            
                            mapped_filename = filename_mapping.get(filename, filename)
                            dest_path = os.path.join(song_dir, mapped_filename)
                            
                            # Write file to destination
                            with open(dest_path, 'wb') as f:
                                f.write(data)
                            
                            logger.debug(f"Extracted template file: {filename} -> {mapped_filename}")
                            
                logger.info("Extracted template drum sounds")
            else:
                logger.warning("Template file not found, using default drum sounds")
                
        except Exception as e:
            logger.warning(f"Failed to extract template files: {e}")
    
    def _add_template_files(self, zipf: zipfile.ZipFile, song_name: str):
        """Add template files to DTX package (legacy method for compatibility)."""
        logger.warning("Legacy _add_template_files method called - this should not happen with directory output")
        # This method is kept for backward compatibility but should not be used
    
    def validate_dtx_chart(self, chart: DTXChart) -> List[str]:
        """
        Validate DTX chart for common issues.
        
        Args:
            chart: DTX chart to validate
            
        Returns:
            List of validation warnings/errors
        """
        issues = []
        
        # Check metadata
        required_fields = ['title', 'artist', 'author']
        for field in required_fields:
            if not chart.metadata.get(field):
                issues.append(f"Missing required metadata: {field}")
        
        # Check difficulty
        difficulty = chart.metadata.get('difficulty', 0)
        if not isinstance(difficulty, int) or not 1 <= difficulty <= 100:
            issues.append(f"Invalid difficulty: {difficulty} (should be 1-100)")
        
        # Check notes
        if not chart.notes:
            issues.append("Chart contains no notes")
        
        # Check for notes outside valid range
        for note in chart.notes:
            if note.position < 0 or note.position >= self.resolution:
                issues.append(f"Note position out of range: {note.position}")
            
            if note.velocity < 0 or note.velocity > 127:
                issues.append(f"Invalid velocity: {note.velocity}")
        
        # Check bar distribution
        if chart.notes:
            bars_with_notes = set(note.bar for note in chart.notes)
            if len(bars_with_notes) < 2:
                issues.append("Chart has notes in very few bars")
        
        return issues
    
    def _validate_dtx_package(self, song_dir: str, bgm_format: str) -> List[str]:
        """
        Validate that DTX package contains all required files.
        
        Args:
            song_dir: Directory containing DTX package
            bgm_format: Expected BGM format
            
        Returns:
            List of validation issues
        """
        issues = []
        
        # Check DTX file
        song_name = os.path.basename(song_dir)
        dtx_file = os.path.join(song_dir, f"{song_name}.dtx")
        if not os.path.exists(dtx_file):
            issues.append(f"DTX file not found: {dtx_file}")
        
        # Check BGM file
        bgm_file = os.path.join(song_dir, f"bgm.{bgm_format}")
        bgm_separated_file = os.path.join(song_dir, f"bgm_separated.{bgm_format}")
        
        if not os.path.exists(bgm_file) and not os.path.exists(bgm_separated_file):
            issues.append(f"BGM file not found: expected bgm.{bgm_format} or bgm_separated.{bgm_format}")
        
        # Check drum sound files
        required_drums = [
            'hihat_close.ogg', 'snare.ogg', 'kick.ogg',
            'tom_high.ogg', 'tom_low.ogg', 'ride.ogg',
            'tom_floor.ogg', 'hihat_open.ogg', 'ride_bell.ogg', 'crash.ogg'
        ]
        
        for drum_file in required_drums:
            drum_path = os.path.join(song_dir, drum_file)
            if not os.path.exists(drum_path):
                issues.append(f"Drum sound file not found: {drum_file}")
        
        # Check file sizes
        for file_name in os.listdir(song_dir):
            file_path = os.path.join(song_dir, file_name)
            if os.path.isfile(file_path):
                file_size = os.path.getsize(file_path)
                if file_size == 0:
                    issues.append(f"Empty file: {file_name}")
                elif file_name.endswith('.ogg') and file_size < 1000:
                    issues.append(f"Suspiciously small drum file: {file_name} ({file_size} bytes)")
                elif file_name.startswith('bgm') and file_size < 10000:
                    issues.append(f"Suspiciously small BGM file: {file_name} ({file_size} bytes)")
        
        return issues