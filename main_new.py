"""
New main entry point using the refactored architecture.

This demonstrates how the new modular architecture can be used
while maintaining compatibility with the existing interface.
"""

import sys
import os
import argparse
from pathlib import Path

# Add src to Python path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from audio2dtx.config.settings import load_settings
from audio2dtx.core.audio_processor import AudioProcessor
from audio2dtx.utils.logging import setup_logging
from audio2dtx.utils.validators import validate_audio_file, validate_metadata
from audio2dtx.utils.exceptions import Audio2DTXError


def collect_metadata_interactive(input_filename: str) -> dict:
    """Collect metadata interactively (same as original)."""
    print("\n=== Audio2DTX Metadata Collection ===")
    print("Please provide the following information for your DTX file:")
    print("(Press Enter for default values)")
    
    default_title = os.path.splitext(input_filename)[0]
    
    metadata = {}
    
    # Song title
    title = input(f"Song title [{default_title}]: ").strip()
    metadata['title'] = title if title else default_title
    
    # Artist name
    artist = input("Artist name [Unknown Artist]: ").strip()
    metadata['artist'] = artist if artist else "Unknown Artist"
    
    # Author/Charter
    author = input("Author/Charter [Audio2DTX]: ").strip()
    metadata['author'] = author if author else "Audio2DTX"
    
    # Difficulty level
    while True:
        try:
            difficulty = input("Difficulty level (1-100) [5]: ").strip()
            if not difficulty:
                metadata['difficulty'] = 5
                break
            difficulty_val = int(difficulty)
            if 1 <= difficulty_val <= 100:
                metadata['difficulty'] = difficulty_val
                break
            else:
                print("Please enter a number between 1 and 100.")
        except ValueError:
            print("Please enter a valid number.")
    
    # Use original audio as BGM
    while True:
        use_original = input("Use original audio as BGM? (y/n) [y]: ").strip().lower()
        if not use_original or use_original in ['y', 'yes']:
            metadata['use_original_bgm'] = True
            break
        elif use_original in ['n', 'no']:
            metadata['use_original_bgm'] = False
            break
        else:
            print("Please enter 'y' for yes or 'n' for no.")
    
    # Time signature
    print("\nAvailable time signatures:")
    print("1. 4/4 (default)")
    print("2. 3/4")
    print("3. 6/8")
    print("4. 2/4")
    print("5. 5/4")
    
    time_signatures = {
        '1': '4/4', '2': '3/4', '3': '6/8', '4': '2/4', '5': '5/4'
    }
    
    while True:
        time_sig_choice = input("Select time signature (1-5) [1]: ").strip()
        if not time_sig_choice:
            metadata['time_signature'] = '4/4'
            break
        elif time_sig_choice in time_signatures:
            metadata['time_signature'] = time_signatures[time_sig_choice]
            break
        else:
            print("Please enter a number between 1 and 5.")
    
    # Optional: Genre
    genre = input("Genre [Rock]: ").strip()
    metadata['genre'] = genre if genre else "Rock"
    
    # Optional: Comment
    comment = input("Comment [Auto-generated by Audio2DTX]: ").strip()
    metadata['comment'] = comment if comment else "Auto-generated by Audio2DTX"
    
    # Summary
    print("\n=== Metadata Summary ===")
    print(f"Title: {metadata['title']}")
    print(f"Artist: {metadata['artist']}")
    print(f"Author: {metadata['author']}")
    print(f"Difficulty: {metadata['difficulty']}")
    print(f"Use Original BGM: {'Yes' if metadata['use_original_bgm'] else 'No'}")
    print(f"Time Signature: {metadata['time_signature']}")
    print(f"Genre: {metadata['genre']}")
    print(f"Comment: {metadata['comment']}")
    
    # Confirmation
    while True:
        confirm = input("\nProceed with these settings? (y/n) [y]: ").strip().lower()
        if not confirm or confirm in ['y', 'yes']:
            break
        elif confirm in ['n', 'no']:
            print("Metadata collection cancelled.")
            sys.exit(0)
        else:
            print("Please enter 'y' for yes or 'n' for no.")
    
    return metadata


def get_default_metadata(input_filename: str) -> dict:
    """Get default metadata for batch mode."""
    return {
        'title': os.path.splitext(input_filename)[0],
        'artist': 'Unknown Artist',
        'author': 'Audio2DTX',
        'difficulty': 5,
        'use_original_bgm': True,
        'time_signature': '4/4',
        'genre': 'Rock',
        'comment': 'Auto-generated by Audio2DTX'
    }


def determine_track_type(args) -> str:
    """Determine track type from command line arguments."""
    if args.use_magenta_only:
        return 'magenta_only'
    elif args.use_advanced_features:
        return 'advanced_features'
    elif args.use_multi_scale:
        return 'multi_scale'
    elif args.use_few_shot:
        return 'few_shot'
    elif args.use_ensemble:
        return 'ensemble'
    elif args.use_augmentation:
        return 'augmentation'
    elif args.use_rock_ultimate:
        return 'rock_ultimate'
    else:
        return 'default'


def main():
    """Main entry point for the new architecture."""
    
    # Set up argument parser
    parser = argparse.ArgumentParser(description='Convert audio files to DTXMania charts (New Architecture)')
    parser.add_argument('input_file', help='Input audio file name')
    parser.add_argument('--batch', action='store_true', 
                       help='Run in batch mode (skip metadata prompts)')
    parser.add_argument('--config', help='Configuration file path')
    parser.add_argument('--output-dir', default='/app/output', help='Output directory')
    
    # Metadata arguments
    parser.add_argument('--title', help='Song title')
    parser.add_argument('--artist', help='Artist name')
    parser.add_argument('--author', help='Author/Charter name')
    parser.add_argument('--genre', help='Genre (default: Rock)')
    parser.add_argument('--comment', help='Comment')
    parser.add_argument('--use-original-bgm', action='store_true', default=None,
                       help='Use original audio as BGM')
    parser.add_argument('--no-original-bgm', action='store_true', default=None,
                       help='Do not use original audio as BGM')
    parser.add_argument('--time-signature', choices=['4/4', '3/4', '6/8', '2/4', '5/4'],
                       help='Time signature (default: 4/4)')
    
    # Track selection arguments
    parser.add_argument('--use-magenta-only', action='store_true',
                       help='Track 3: Use only Magenta service for drum classification')
    parser.add_argument('--use-advanced-features', action='store_true',
                       help='Track 4: Use advanced spectral features and enhanced context analysis')
    parser.add_argument('--use-multi-scale', action='store_true',
                       help='Track 5: Use multi-scale temporal analysis')
    parser.add_argument('--use-few-shot', action='store_true',
                       help='Track 6: Use real-time few-shot learning')
    parser.add_argument('--use-ensemble', action='store_true',
                       help='Track 7: Use ensemble of specialized models')
    parser.add_argument('--use-augmentation', action='store_true',
                       help='Track 8: Use advanced preprocessing and data augmentation')
    parser.add_argument('--use-rock-ultimate', action='store_true',
                       help='Track 9: Ultimate rock/metal optimization')
    
    # Debug options
    parser.add_argument('--test-components', action='store_true',
                       help='Test all components and exit')
    parser.add_argument('--verbose', action='store_true',
                       help='Enable verbose logging')
    
    args = parser.parse_args()
    
    # Set up logging
    log_level = "DEBUG" if args.verbose else "INFO"
    setup_logging(log_level)
    
    # Load settings
    settings = load_settings(args.config)
    
    # Initialize processor
    processor = AudioProcessor(settings)
    
    # Test components if requested
    if args.test_components:
        print("Testing components...")
        test_results = processor.test_components()
        
        for component, result in test_results.items():
            status = "‚úÖ PASS" if result else "‚ùå FAIL"
            print(f"{component}: {status}")
        
        sys.exit(0)
    
    # Validate input file
    input_audio = f"/app/input/{args.input_file}"
    
    try:
        input_audio = validate_audio_file(input_audio)
    except Exception as e:
        print(f"‚ùå Error: {e}")
        sys.exit(1)
    
    # Collect metadata
    if args.batch:
        metadata = get_default_metadata(args.input_file)
        print("Running in batch mode - using default metadata")
    else:
        metadata = collect_metadata_interactive(args.input_file)
    
    # Override with command line arguments
    if args.title:
        metadata['title'] = args.title
    if args.artist:
        metadata['artist'] = args.artist
    if args.author:
        metadata['author'] = args.author
    if args.genre:
        metadata['genre'] = args.genre
    if args.comment:
        metadata['comment'] = args.comment
    if args.use_original_bgm is not None:
        metadata['use_original_bgm'] = args.use_original_bgm
    if args.no_original_bgm is not None:
        metadata['use_original_bgm'] = not args.no_original_bgm
    if args.time_signature:
        metadata['time_signature'] = args.time_signature
    
    # Validate metadata
    try:
        metadata = validate_metadata(metadata)
    except Exception as e:
        print(f"‚ùå Metadata validation error: {e}")
        sys.exit(1)
    
    # Determine track type
    track_type = determine_track_type(args)
    
    # Create output directory
    os.makedirs(args.output_dir, exist_ok=True)
    
    try:
        print(f"üéµ Starting processing: {args.input_file}")
        print(f"üéØ Track type: {track_type}")
        
        # Process audio file
        dtx_path = processor.process_audio_file(
            input_file=input_audio,
            output_dir=args.output_dir,
            metadata=metadata,
            track_type=track_type
        )
        
        # Get processing results
        results = processor.get_processing_results()
        
        print(f"‚úÖ Successfully converted {args.input_file} to DTXMania simfile")
        print(f"üìÅ Output saved to: {dtx_path}")
        print(f"üéµ Tempo: {results.get('beat_result', {}).get('tempo_bpm', 'Unknown')} BPM")
        print(f"ü•Å Onsets detected: {results.get('onset_count', 0)}")
        print(f"üé∂ Notes generated: {results.get('classified_count', 0)}")
        
    except Audio2DTXError as e:
        print(f"‚ùå Audio2DTX Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        sys.exit(1)
    finally:
        # Clean up
        processor.cleanup()


if __name__ == "__main__":
    main()